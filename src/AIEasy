import java.util.ArrayList;

public class AIEasy implements AIInterface {
	int human = 0;	//change if human player can switch between 0 and 1
	int computer = 1;
	
	public int decideMove(GameState gs) {
		int bestMove = 0;
		int bestPriority = 0;
		
		//loop through all possible moves giving each a priority value
		//and recording the move with the highest value
		for (int col = 0; col < 7; col++) {
			int currPriority = 0;
			
			//cant place move when column is full
			if (gs.getBoard().get(col).size() >= 6) {
				continue;
			}
			
			//winning is the top priority
			if (gs.winCond(col, computer)) {
				return col;
			}
			
			//blocking the player's win is second priority
			if (gs.winCond(col, human)) {
				return col;
			}
			
			//we run helper functions only after checking win conditions
			//since doing so beforehand is a waste
			currPriority += horizontalPriority(gs, col);
			currPriority += verticalPriority(gs, col);
			
			//if this move is better than previous moves, switch to this move
			if (currPriority >= bestPriority) {
				bestMove = col;
				bestPriority = currPriority;
			}
		}
		return bestMove;
	}
	
	/**
	 * Helper function to check whether this move is close to a 4 in a row, horizontally
	 */
	public int horizontalPriority(GameState gs, int column) {
		ArrayList<ArrayList<Integer>> board = gs.getBoard();
		int row = board.get(column).size();	//before we make the move hence no '-1'
		int connected = 1;	//amount of connected horizontal tiles, starts at one to count the column tile
		int free = 0;
		
		//check the left side of the column
		int horBreak = 1;
		for (int col = column - 1; col >= 0; col--) {
			//if there is no tile 
			if ((row >= board.get(col).size())) {
				free++;
				horBreak = 0;
			}
			
			//check number of connected to the left
			if ((horBreak == 1) && (board.get(col).get(row) == computer)) {
				connected++;
			} else {
				horBreak = 0;
			}
		}
		
		//check the right side of the column
		horBreak = 1;
		for (int col = column + 1; col < 7; col++) {
			//if there is no tile 
			if ((row >= board.get(col).size())) {
				free++;
				horBreak = 0;
			}
			
			//check number of connected to the right
			if ((horBreak == 1) && (board.get(col).get(row) == computer)) {
				connected++;
			} else {
				horBreak = 0;
			}
		}
		
		//no horizontal if there is no free space for a 4 in a row
		if (free < 4 - connected) {
			return 0;
		} else {
			//if there can be a 4 in a row return how close we are
			return connected;
		}
	}
	
	/**
	 * Helper function to check whether this move is close to a 4 in a row, Vertically
	 */
	public int verticalPriority(GameState gs, int column) {
		ArrayList<ArrayList<Integer>> board = gs.getBoard();
		int row = board.get(column).size();	//before we make the move hence no '-1'
		int connected = 1;	//amount of connected vertical tiles, starts at one to count the column tile
		int free = 5 - row;	//free slots left besides our next move
		
		//check how many are connected underneath
		for (int y = row-1; y >= 0; y--) {
			if (board.get(column).get(y) == computer) {
				connected++;
			} else {
				break;
			}
		}
		
		if (free < 4 - connected) {
			//no vertical priority if not enough space for a vertical
			return 0;
		} else {
			//if there is space for a 4 in a row, return how close we are
			return connected;
		}
	}

}
